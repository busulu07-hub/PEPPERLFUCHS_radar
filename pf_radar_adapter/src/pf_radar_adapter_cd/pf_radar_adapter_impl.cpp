// --------------------------------------------------------
// Copyright (c)
//
// contributions by author
//                  author@somewhere.net
// maintained by    maintainer
//                  maintainer@somewhere.net
//
// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define pf_radar_adapter_cd_pf_radar_adapter_impl_BODY

/************************************************************
 pf_radar_adapter_impl class body
 ************************************************************/

// include associated header file
#include "pf_radar_adapter_cd/pf_radar_adapter_impl.h"

// Derived includes directives
#include "rclcpp/rclcpp.hpp"
#include <algorithm>     // for std::min
#include <limits>        // for std::numeric_limits
#include "std_msgs/msg/header.hpp"
#include "canopen_interfaces/msg/co_data.hpp"
#include "pf_radar_interfaces_sd/msg/radar.hpp"

namespace pf_radar_adapter_cd {

// --------------------------------------------------------
// Constants and simple variables (stay inside this file only)
// --------------------------------------------------------
namespace {
  constexpr uint16_t OBJ_2000    = 0x2000;  // object dictionary index
  constexpr uint8_t  SUB_DIST    = 0x01;    // distance
  constexpr uint8_t  SUB_VEL     = 0x02;    // velocity
  constexpr uint8_t  SUB_QUAL    = 0x03;    // signal quality
  constexpr uint8_t  SUB_CYC8    = 0x05;    // cyclic counter
  constexpr uint16_t NO_OBJECT16 = 0x7FFF;  // "no object" code

  // latest values (simple file-level variables)
  double  g_last_distance_m   = std::numeric_limits<double>::quiet_NaN();
  double  g_last_velocity_mps = std::numeric_limits<double>::quiet_NaN();
  double  g_last_quality_pct  = std::numeric_limits<double>::quiet_NaN();
  uint8_t g_last_counter      = 0;

  const char* G_FRAME_ID = "pf_radar_link";  // coordinate frame name
} // end anonymous namespace

// static attributes (if any)

/**
 * @brief Constructor
 * @param options standard NodeOptions
 */
pf_radar_adapter_impl::pf_radar_adapter_impl(rclcpp::NodeOptions /*in*/options)
: pf_radar_adapter(options)
{
}

/**
 * @brief Publishes the radar message with the latest converted data.
 */
void pf_radar_adapter_impl::radar_publisher()
{
  // Create the publisher once (first call only)
  static rclcpp::Publisher<pf_radar_interfaces_sd::msg::Radar>::SharedPtr pub =
      this->create_publisher<pf_radar_interfaces_sd::msg::Radar>("radar", 10);

  // Create and fill the message
  pf_radar_interfaces_sd::msg::Radar msg;

  // --- Header ---
  msg.header.stamp    = this->now();     // current ROS time
  msg.header.frame_id = G_FRAME_ID;      // coordinate frame name

  // --- Data (already converted to SI units) ---
  msg.distance       = g_last_distance_m;    // meters
  msg.velocity       = g_last_velocity_mps;  // m/s
  msg.signal_quality = g_last_quality_pct;   // percent 0..100
  msg.counter        = g_last_counter;       // 8-bit cyclic counter

  // Publish the message
  pub->publish(msg);
}

/**
 * @brief Handles incoming COData (RPDO) and updates latest radar values.
 * @param commobj received CANopen data object
 */
void pf_radar_adapter_impl::co_data_handler(
    const canopen_interfaces::msg::COData::SharedPtr commobj)
{
  // We only care about object 0x2000
  if (commobj->index != OBJ_2000)
    return;

  const uint8_t  sub = commobj->subindex;
  const uint32_t raw = static_cast<uint32_t>(commobj->data);

  // Convert depending on subindex
  if (sub == SUB_DIST) {
    // Distance: uint16 mm → m
    const uint16_t raw_mm = static_cast<uint16_t>(raw & 0xFFFF);
    if (raw_mm == NO_OBJECT16)
      g_last_distance_m = std::numeric_limits<double>::quiet_NaN();
    else
      g_last_distance_m = static_cast<double>(raw_mm) * 0.001; // 1 mm = 0.001 m
  }
  else if (sub == SUB_VEL) {
    // Velocity: int16 cm/s → m/s
    const int16_t raw_cms = static_cast<int16_t>(raw & 0xFFFF);
    if (static_cast<uint16_t>(raw_cms) == NO_OBJECT16)
      g_last_velocity_mps = std::numeric_limits<double>::quiet_NaN();
    else
      g_last_velocity_mps = static_cast<double>(raw_cms) / 100.0; // 100 cm = 1 m
  }
  else if (sub == SUB_QUAL) {
    // Signal quality: uint8 (0..20) → percentage ×5
    const uint8_t q_raw = static_cast<uint8_t>(raw & 0xFF);
    const int pct = std::min<int>(q_raw * 5, 100);
    g_last_quality_pct = static_cast<double>(pct);
  }
  else if (sub == SUB_CYC8) {
    // Cyclic counter (8-bit)
    g_last_counter = static_cast<uint8_t>(raw & 0xFF);
  }
  else {
    // Ignore anything else
    return;
  }

  // Publish updated message
  radar_publisher();
}

} // of namespace pf_radar_adapter_cd

/************************************************************
 End of pf_radar_adapter_impl class body
 ************************************************************/
